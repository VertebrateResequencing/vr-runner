#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#
# This script/pipeline is intended for chaining multiple runners. It runs as a
# daemon and waits for new projects to appear in dropbox directory ("input_dir").
# The projects are small text files which define the input data, such as:
#
#   # Where to send notification about job completion
#   email: someone@somewhere.org
#
#   # Frequency (in seconds) with which to remind about failed jobs 
#   err_period: 3600
#
#   # Any value given as "$(var_name)" in the config can be overriden.
#   # The default value can be given as "$(var_name:default)"
#   maxjobs: 200
#
# After the runners finish, the result is moved to output directory and an
# email is sent to notify the user.
#
# The pipeline chain can be run from the command line
#
#   run-runners -v -c config.conf
#
# or as a cron job:
#
#   */5 *  *   *   *     vr-wrapper ~/.vrw/runners 'run-runners -v -c config.conf -L config.lock'    
#
# The vr-wrapper scripts can be used to set environment variables without having
# to change user's profile. It may look as this:
#
#   #!/bin/bash
#   export PATH="$HOME/git/vr-runner/scripts:$PATH"
#   export PERL5LIB="$HOME/git/vr-runner/modules:$PERL5LIB"
#   
#

use strict;
use warnings;
use Carp;
use Cwd;

my $opts = parse_params();

create_lock($opts);
while (1)
{
    my $projects = list_projects($opts);
    for my $project (@$projects)
    {
        run_project($opts,$project);
    }
    if ( !$$opts{loop} ) { last; }
    print STDERR "sleeping..\n" unless !$$opts{verbose};
    sleep($$opts{loop});
}
remove_lock($opts);

exit;

#--------------------------------

sub error
{
    my (@msg) = @_;
    if ( scalar @msg ) { confess @msg; }
    print 
        "Usage: run-runners [OPTIONS]\n",
        "Options:\n",
        "   -c, --config <file>     config file\n",
        "   -i, --ignore-failures   continue with other projects even if one keeps failing\n",
        "   -l, --loop <int>        run in daemon mode, check the status every <int> seconds\n",
        "   -L, --lock <file>       exit if another instance is already running\n",
        "   -n, --nmax <int>        maximum number of projects to run simultaneously\n",
        "   -v, --verbose           print what's been done\n",
        "   -h, -?, --help          this help message\n",
        "\n";
    exit -1;
}

sub parse_params
{
    my $opts = { nmax_projects=>1 };
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq '-i' || $arg eq '--ignore-failures' ) { $$opts{ignore_failures}=1; next }
        if ( $arg eq '-n' || $arg eq '--nmax' ) { $$opts{nmax_projects}=shift(@ARGV); next }
        if ( $arg eq '-L' || $arg eq '--lock' ) { $$opts{lock}=shift(@ARGV); next }
        if ( $arg eq '-l' || $arg eq '--loop' ) { $$opts{loop}=shift(@ARGV); next }
        if ( $arg eq '-c' || $arg eq '--config' ) { $$opts{config}=shift(@ARGV); next }
        if ( $arg eq '-v' || $arg eq '--verbose' ) { $$opts{verbose}=1; next }
        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
        error("Unknown parameter \"$arg\". Run -h for help.\n");
    }
    if ( !exists($$opts{config}) ) { error("Missing the -c option.\n") }
    my %x = do "$$opts{config}";
    if ( $@ ) { error("do $$opts{config}: $@\n"); }
    %$opts = (%$opts,%x);

    if ( !-e $$opts{work_dir} ) { `mkdir -p $$opts{work_dir}`; }
    if ( !-e $$opts{input_dir} ) { `mkdir -p $$opts{input_dir}`; }
    if ( !-e $$opts{output_dir} ) { `mkdir -p $$opts{output_dir}`; }

    return $opts;
}

sub create_lock
{
    my ($opts) = @_;

    if ( !exists($$opts{lock}) ) { return; }

    my $lock = $$opts{lock};
    if ( -e $lock )
    {
        # Find out the PID of the running pipeline
        open(my $fh,'<',$lock) or error("$lock; $!");
        while (my $pid=<$fh>)
        {
            chomp($pid);
            if ( !($pid=~/^\d+$/) ) { die "Could not parse lock file: $lock, $pid\n"; }

            # Is the process still running?
            my $running = kill 0, $pid;
            if ( $running )
            {
                my @out = `ps --no-headers -p $pid -o command`;
                my $script_name = $0;
                $script_name =~ s{^.*/}{};
                if ( $out[0]=~/$script_name/ )
                {
                    die "Another process is running ($pid), exiting.\n";
                }
            }

            print STDERR "Ignoring an old lock file, PID $pid is not running.\n";
            last;
        }
        close($fh);
    }

    open(my $fh,'>',$lock) or error("$lock: $!");
    print $fh $$ . "\n";
    close($fh);
}

sub remove_lock
{
    my ($opts) = @_;
    if ( !exists($$opts{lock}) ) { return; }
    my $lock = $$opts{lock};
    if ( -e $lock ) { unlink($lock); }
}

sub list_projects
{
    my ($opts) = @_;
    my @projects = ();

    # First check projects in progress
    my ($dh,$project);
    opendir($dh, $$opts{work_dir}) or error("$$opts{work_dir}: $!");
    while (my $dir = readdir($dh))
    {
        if ( !-d "$$opts{work_dir}/$dir" or !($dir=~/^\d+_(.*)$/ ) ) { next; }
        $project = parse_project($opts,"$$opts{work_dir}/$dir/$1.txt");
        push @projects, $project;
        if ( scalar @projects >= $$opts{nmax_projects} ) { last; }
    }
    closedir($dh);
    if ( scalar @projects >= $$opts{nmax_projects} ) { return \@projects; }


    # No unfinished projects, check for new
    opendir($dh, $$opts{input_dir}) or error("$$opts{input_dir}: $!");
    while (my $file = readdir($dh))
    {
        if ( $file =~/^\./ ) { next; }
        if ( $file =~/~$/ ) { next; }
        if ( $file =~/\.err$/ ) { next; }
        $project = parse_project($opts,"$$opts{input_dir}/$file");
        $$project{alias} = time() .'_'. $$project{name};
        $$project{file}  = $file;

        system("mkdir -p $$opts{work_dir}/$$project{alias}");
        system("mv $$opts{input_dir}/$$project{file} $$opts{work_dir}/$$project{alias}/$$project{file}.txt");
        if ( $? ) { confess "mv $$opts{input_dir}/$$project{file} $$opts{work_dir}/$$project{alias}/$$project{file}.txt"; }

        push @projects, $project;
        if ( scalar @projects >= $$opts{nmax_projects} ) { last; }
    }
    closedir($dh);
    return \@projects;
}

sub clean_project
{
    my ($opts,$project) = @_;

    my $name = $$project{name};
    debug_msg($opts,"Cleaning project: $name\n");
    $name =~ s/\.txt$//;
    $$project{prefix} = "$$opts{work_dir}/$$project{alias}/$name";

    for my $outdir (keys %{$$opts{outputs}})
    {
        system("mkdir -p $$opts{output_dir}/$$project{alias}/$outdir");
        for my $file (@{$$opts{outputs}{$outdir}})
        {
            my $path = expand_vars($opts,$project,$file);
            system("mv $path $$opts{output_dir}/$$project{alias}/$outdir/");
        }
    }

    system("mkdir -p $$opts{output_dir}/$$project{alias}/tmp-data");
    system("mv $$opts{work_dir}/$$project{alias} $$opts{output_dir}/$$project{alias}/tmp-data");
}

# Parse the project definition
sub parse_project
{
    my ($opts,$file) = @_;
    if ( !($file=~m{^(.+)/([^/]+)$}) ) { error("Could not parse dir/fname: $file\n"); }
    my $dir  = $1;
    my $name = $2;
    my %project = ();
    open(my $fh,'<',$file) or error("$file: $!");
    while (my $line=<$fh>)
    {
        if ( $line=~/^#/ ) { next; }
        if ( $line=~/^\s*$/ ) { next; }
        $line =~ s/^\s*//;
        $line =~ s/\s*$//;
        if ( !($line=~/^\s*([^:]+)\s*:/) ) { error("Could not parse $file: $line\n"); }
        my $key = $1;
        my $value = $';
        $value =~ s/^\s*//;
        $value =~ s/\s*$//;
        $key   =~ s/\s*$//;
        $project{$key} = $value;
    }
    close($fh) or error("close failed: $file");
    $project{dir}  = $dir;
    $project{name} = $name;
    if ( $dir=~m{^.+/(\d+_[^/]+)$} ) { $project{alias} = $1; }
    return \%project;
}

# Replace variables $(var_name)
sub expand_vars
{
    my ($opts,$project,$str) = @_;
    pos($str) = 0;
    while ( ($str =~ /\G(.*?)\$\(([^\)]+)\)/s) )
    {
        pos($str) += length($&);
        if ( exists($$project{$2}) ) 
        { 
            $str = $` . $1 . $$project{$2} . $'; 
            next; 
        }
        elsif ( exists($$opts{$2}) )
        { 
            $str = $` . $1 . $$opts{$2} . $'; 
            next; 
        }
    }
    pos($str) = 0;
    while ( ($str =~ /\G(.*?)\$\(([^\)]+):([^\)]+)\)/s) )
    {
        pos($str) += length($&);
        if ( exists($$project{$2}) ) 
        { 
            $str = $` . $1 . $$project{$2} . $'; 
            next; 
        }
        elsif ( exists($$opts{$2}) )
        { 
            $str = $` . $1 . $$opts{$2} . $'; 
            next; 
        }
        else
        {
            $str = $` . $1 . $3 . $';
        }
    }
    return $str;
}

sub first_file_newer
{
    my ($a,$b) = @_;
    my $atime = (stat($a))[9];
    my $btime = (stat($b))[9];
    return $atime > $btime ? 1 : 0;
}

sub debug_msg
{
    my ($opts,@msg) = @_;
    if ( !$$opts{verbose} ) { return; }
    print STDERR join('',@msg);
}

# Create config file for each task (if the key "config" exists for the task)
# and run all runners until finished.
sub run_project
{
    my ($opts,$project) = @_;
    my $name = $$project{name};
    debug_msg($opts,"Checking status: $name\n");
    $name =~ s/\.txt$//;
    for my $task (@{$$opts{tasks}})
    {
        my $prefix = "$$opts{work_dir}/$$project{alias}/$name";
        debug_msg($opts, "Checking task: $prefix.$task.done\n");
        if ( -e "$prefix.$task.done" ) 
        { 
            debug_msg($opts, "Task done: $prefix\n");
            next; 
        }
        if ( ! -e "$prefix.$task" ) { system("mkdir -p $prefix.$task"); }
        $$project{prefix} = $prefix;

        if ( exists($$opts{$task}{config}) && (!-e "$prefix.$task.conf" or first_file_newer($$opts{config},"$prefix.$task.conf")) )
        {
            my $config = expand_vars($opts,$project,$$opts{$task}{config});
            open(my $fh,'>',"$prefix.$task.conf.part") or error("$prefix.$task.conf.part: $!");
            print $fh $config;
            close($fh) or error("close failed: $prefix.$task.conf.part");
            rename("$prefix.$task.conf.part","$prefix.$task.conf") or error("rename $prefix.$task.conf.part $prefix.$task.conf: $!");
        }

        my $cwd;
        if ( $$opts{chdir_into_project} )
        {
            $cwd = getcwd;
            chdir("$$opts{work_dir}/$$project{alias}");
            print STDERR "chdir $$opts{work_dir}/$$project{alias}\n";
            $$project{prefix} = $name;
        }
        my $ret = run_task($opts,$project,$task);
        if ( defined $cwd ) { chdir($cwd); }
        if ( !$ret ) { return; }

        system("touch $prefix.$task.done");
        if ( $? ) { confess "touch $prefix.$task.done"; }
    }
    clean_project($opts,$project);
    send_email($project,"The project \"$name\" finished","The project \"$name\" finished");
}


# Run a single runner
sub run_task
{
    my ($opts,$project,$task_name) = @_;
    my $task = $$opts{$task_name};
    for my $job (@{$$task{run}})
    {
        my $cmd = expand_vars($opts,$project,$$job{cmd});
        debug_msg($opts, "Running task: $cmd\n");

        if ( !exists($$job{status}) ) { $$job{status}{done} = 0; }

        while ( 1 )
        {
            print STDERR "$cmd\n";
            system($cmd);

            my $status = $? >> 8;

            if ( exists($$job{status}{error}) && $status==$$job{status}{error} )
            {
                send_err_email($project,"$task_name failed","Project $$project{name} failed: $cmd");
                if ( $$opts{ignore_failures} )
                {
                    print STDERR "Failed: $cmd\n\n";
                    return 0;   # Act as if the task was not finished
                }
                error("Failed: $cmd"); 
            }

            if ( $status==$$job{status}{done} ) { last; }

            if ( !exists($$job{loop}) )
            { 
                if ( !exists($$job{status}{error}) )
                { 
                    send_err_email($project,"$task_name failed","Project $$project{name} failed: $cmd");
                    if ( $$opts{ignore_failures} )
                    {
                        print STDERR "Failed: $cmd\n\n";
                        return 0;   # Act as if the task was not finished
                    }
                    error("Failed: $cmd"); 
                }
                last;
            }

            if ( $status==$$job{status}{loop} )
            {
                if ( !$$opts{loop} ) { return 0; }
                sleep($$job{loop}); 
            }
            else 
            { 
                send_err_email($project,"$task_name error","Unexpected return status: status ($?): $cmd\nProject $$project{name}\n");
                if ( $$opts{ignore_failures} )
                {
                    print STDERR "Failed: $cmd\n\n";
                    return 0;   # Act as if the task was not finished
                }
                error("Unexpected return status: $status ($?) .. $cmd"); 
            }
        }
    }
    return 1;
}

sub send_email
{
    my ($opts, $status, @msg) = @_;
    if ( !exists($$opts{email}) ) { return; }
    open(my $mh,"| mail -s 'Runner report: $status' $$opts{email}");
    print $mh join('',@msg) . "\n";
    close($mh);
}
sub send_err_email
{
    my ($opts, $status, @msg) = @_;
    if ( !exists($$opts{email}) ) { return; }
    if ( exists($$opts{err_period}) )
    {
        my $err_file = "$$opts{dir}/$$opts{prefix}.err";
        if ( -e $err_file ) 
        {
            if ( !update_after_delta($err_file,$$opts{err_period}) ) { return; }
        }
        open(my $fh,'>',$err_file) or error("$err_file: $!");
        my $now = time();
        print $fh $now;
        close($fh) or error("$err_file: close failed");
    }
    send_email($opts, $status, @msg);
}

sub update_after_delta
{
    my ($err_file,$period) = @_;
    my $now = time();
    my $ret = open(my $fh,'<',$err_file);
    if ( $ret )
    {
        my $then = <$fh>;
        close($fh);
        if ( $then )
        {
            chomp($then);
            if ( $then + $period > $now ) { return 0; }
        }
    }
    open($fh,'>',$err_file) or return 1;
    print $fh $now;
    close($fh);
    return 1;
}


