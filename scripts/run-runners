#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#
# See run-runners --usage for a detailed help.
#

use strict;
use warnings;
use Carp;
use Cwd;
use IPC::Run3;
use POSIX;

my $opts = parse_params();

create_lock($opts);
while (1)
{
    my $projects = list_projects($opts);
    for my $project (@$projects)
    {
        run_project($opts,$project);
    }
    update_html_report($opts,$projects);

    if ( !$$opts{loop} ) { last; }
    print STDERR "sleeping $$opts{loop} seconds..\n" unless !$$opts{verbose};
    sleep($$opts{loop});
}
remove_lock($opts);

exit;

#--------------------------------

sub error
{
    my (@msg) = @_;
    if ( scalar @msg ) { confess @msg; }
    print 
        "About: Maintain a dropbox-style runner chains.\n",
        "Usage: run-runners [OPTIONS]\n",
        "Options:\n",
        "   -a, --admin <email>       admin email address\n",
        "   -e, --err-period <int>    wait <int> minutes before sending more emails about failing jobs\n",
        "   -d, --dropbox <prefix>    prefix to dropbox directory (read \"run-runners --usage\" first!)\n",
        "   -i, --ignore-failures     continue with other projects even if one keeps failing\n",
        "   -l, --loop <int>          run in daemon mode, check the status every <int> seconds\n",
        "   -L, --lock <file>         exit if another instance is already running\n",
        "   -n, --nmax <int>          maximum number of projects to run simultaneously\n",
        "   -s, --setup <file>        run directly\n",
        "   -u, --usage               print detailed usage explanation\n",
        "   -v, --verbose             increase verbosity by giving multiple times\n",
        "   -h, -?, --help            this help message\n",
        "Examples:\n",
        "   run-runners --usage | less          # detailed usage explanation\n",
        "   run-runners -v -d prefix -l 300     # loop with sleep cycles of 300 seconds\n",
        "\n";
    exit -1;
}

sub parse_params
{
    my $opts = { };
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq '-s' || $arg eq '--setup' ) { $$opts{run_setup}=shift(@ARGV); next; }
        if ( $arg eq '-u' || $arg eq '--usage' ) { detailed_usage(); exit; }
        if ( $arg eq '-a' || $arg eq '--admin' ) { $$opts{admin_email}=shift(@ARGV); next }
        if ( $arg eq '-d' || $arg eq '--dropbox' ) { $$opts{dropbox}=shift(@ARGV); next }
        if ( $arg eq '-e' || $arg eq '--err-period' ) { $$opts{err_period}=shift(@ARGV); next }
        if ( $arg eq '-i' || $arg eq '--ignore-failures' ) { $$opts{ignore_failures}=1; next }
        if ( $arg eq '-n' || $arg eq '--nmax' ) { $$opts{nmax_projects}=shift(@ARGV); next }
        if ( $arg eq '-L' || $arg eq '--lock' ) { $$opts{lock}=shift(@ARGV); next }
        if ( $arg eq '-l' || $arg eq '--loop' ) { $$opts{loop}=shift(@ARGV); next }
        if ( $arg eq '-v' || $arg eq '--verbose' ) { $$opts{verbose}++; next }
        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
        error("Unknown parameter \"$arg\". Run -h for help.\n");
    }
    if ( !exists($$opts{dropbox}) ) { error("Missing the --dropbox option.\n"); }

    $$opts{dropbox_tmp}  = "$$opts{dropbox}.tmp";
    $$opts{dropbox_in}   = "$$opts{dropbox}.in";
    $$opts{dropbox_out}  = "$$opts{dropbox}.out";
    $$opts{dropbox_conf} = "$$opts{dropbox}.conf";
    $$opts{dropbox_html} = "$$opts{dropbox}.html";

    if ( exists($$opts{run_setup}) ) { setup_on_the_fly($opts); }
    if ( !-d $$opts{dropbox_conf} ) { error("Incorrect dropbox prefix, the directory not found: $$opts{dropbox_conf}\n\n"); }
    if ( !-e $$opts{dropbox_in} ) { `mkdir -p $$opts{dropbox_in}`; }
    if ( !-e $$opts{dropbox_out} ) { `mkdir -p $$opts{dropbox_out}`; }
    if ( !-e $$opts{dropbox_tmp} ) { `mkdir -p $$opts{dropbox_tmp}`; }
    if ( !exists($$opts{err_period}) ) { $$opts{err_period} = 60; }

    return $opts;
}

sub setup_on_the_fly
{
    my ($opts) = @_;

    my $dropbox_dir = $$opts{dropbox};
    $$opts{dropbox}      = "$$opts{dropbox}/dropbox";
    $$opts{dropbox_tmp}  = "$$opts{dropbox}.tmp";
    $$opts{dropbox_in}   = "$$opts{dropbox}.in";
    $$opts{dropbox_out}  = "$$opts{dropbox}.out";
    $$opts{dropbox_conf} = "$$opts{dropbox}.conf";
    $$opts{dropbox_html} = "$$opts{dropbox}.html";

    my $name = $$opts{run_setup};
    if ( $name =~ m{^.+/} ) { $name = $'; }
    if ( -e "$$opts{dropbox_in}/$name") { return; }
    if ( scalar glob("$$opts{dropbox_tmp}/*_$name") ) { return; }
    if ( scalar glob("$$opts{dropbox_out}/*_$name") ) { return; }

    open(my $fh,'<',$$opts{run_setup}) or error("$$opts{run_setup}: $!");
    my $conf_dir = undef;
    my @setup    = ();
    while (my $line=<$fh>)
    {
        if ( $line=~/^.config:\s*(\S+)$/ ) 
        { 
            my $chain = $1;
            if ( $chain=~m{^.+/} ) 
            { 
                $conf_dir = $&; 
                $line  = ".config: $'\n";
            }
        }
        push @setup, $line;
    }
    close($fh) or error("close failed: $$opts{run_setup}");

    `mkdir -p $dropbox_dir`;
    if ( defined $conf_dir ) { cmd($opts,"cd $dropbox_dir && ln -s $conf_dir dropbox.conf"); }

    `mkdir -p $$opts{dropbox_in}`;
    open($fh,'>',"$$opts{dropbox_in}/$name") or error("$$opts{dropbox_in}/$name: $!");
    print $fh join('',@setup);
    close($fh) or error("close failed: $$opts{dropbox_in}/$name");
}

sub detailed_usage
{
    print << "EOT";

 Runner pipelines
 ----------------

 This lightweight pipeline framework is intended for chaining multiple runners.
 It runs as a daemon and waits for new projects to appear in a dropbox
 directory. After completion, the results appear in output directory and the
 user is notified by an email. Multiple users can use the same dropbox to run
 different pipelines at the same time.
 
 The following directory structure is assumed:
 
   prefix.conf .. config directory which contains pipeline definitions. 
                   Typically this is a symbolic link to the vr-runner/misc
                   install directory.  This is the only requirement, the rest
                   is created automatically by the pipeline
   prefix.in   .. dropbox input directory, drop your project here
   prefix.out  .. output directory, the result will appear here
   prefix.tmp  .. working directory
 
 
 Each pipeline chain consists of a series of "steps" defined in the misc/chain.*.conf
 and misc/step.*.conf files. These configs can be used as they are. If well
 written, the user only needs to create a small project description and place it
 in the dropbox input directory:

    .config:         chain.gtcheck.conf
    .email:          someone\@somewhere.org
    mpileup/alns:    bams.list
    mpileup/fa_ref:  human_g1k_v37.fasta

 The project descriptions are small text files which define the input data.
 All keys prefixed with a dot are specific to the project, the rest are config
 keys specific to one or multiple steps:

   # The pipeline config, known also as the "chain file". Note that in order to
   # avoid the execution of an arbitrary code passed by a malicious user, the config
   # must be a file name with any leading directory components removed. The file
   # must exist in the dropbox config directory:
   .config: chain.pipeline.conf
 
   # The rest is optional and pipeline-specific. There are a few pipeline-wide 
   # options that are recognised by all pipelines, such as where to send email 
   # notifications about job completion and failures:
   .email: someone\@somewhere.org someone.else\@somewhere.else.org
 
   # Frequency (in minutes) with which to remind about failed jobs, so that
   # the mailbox does not end up cluttered by emails. If not given, the default
   # of 60 minutes is used:
   .err_period: 60
 
   # Any key in a runner's config file can be overriden. For example, if a pipeline
   # chain includes a runner step named "step_name" which recognises the config 
   # key "var_name", the default key can be overriden as:
   step_name/var_name: new value

   # If multiple steps share the same config key, a comma-separated list of
   # steps can be given or leave out the step name to set the key in all steps:
   step1,step2/var_name: new value
   var_name: new value

   # Also substrings in a runner's config file can be expanded. For example,
   # if the config contains the following key-value pair
   #   key => 'some \$(value)',
   # the variable "\$(value)" can be replaced with "new value":
   step_name/value: new value
 
   # Note: if the project description does not specify the "step_name/value" key,
   # the variable "\$(value)" will be replaced with empty string.
 
   # In order to preserve compactness of project descriptions yet allowing flexibility,
   # the runner's config files can use default values. For example, if the config
   # contains the following key-value pair
   #    step_name/key => 'some \$(value:sensible default)',
   # the project description file can override the value but in case it does not,
   # the key will be expanded as follows
   #    step_name/key => 'some sensible default',
 
   # To undefine a pre-defined key, pass "undef"
   step/key: undef      # undefine a key
   step/key: 'undef'    # pass string "undef"
   
   # See the misc/*conf files for real-life examples.
 
 
 The pipeline chain can be run from the command line:
 
   run-runners -v -d prefix            # one iteration
   run-runners -v -d prefix -l 300     # loop with sleep cycles of 300 seconds
 
 or from cron:
 
   */5 *  *   *   *     vr-wrapper ~/.vrw/runners 'run-runners -v -d prefix -L config.lock'    
 
 The vr-wrapper scripts can be used to set environment variables without having
 to change user's profile. It may look as this:
 
   #!/bin/bash
   export PATH="\$HOME/git/vr-runner/scripts:\$PATH"
   export PERL5LIB="\$HOME/git/vr-runner/modules:\$PERL5LIB"
   
EOT
}


sub create_lock
{
    my ($opts) = @_;

    if ( !exists($$opts{lock}) ) { return; }

    my $lock = $$opts{lock};
    if ( -e $lock )
    {
        # Find out the PID of the running pipeline
        open(my $fh,'<',$lock) or error("$lock; $!");
        while (my $pid=<$fh>)
        {
            chomp($pid);
            if ( !($pid=~/^\d+$/) ) { die "Could not parse lock file: $lock, $pid\n"; }

            # Is the process still running?
            my $running = kill 0, $pid;
            if ( $running )
            {
                my @out = `ps --no-headers -p $pid -o command`;
                my $script_name = $0;
                $script_name =~ s{^.*/}{};
                if ( $out[0]=~/$script_name/ )
                {
                    die "Another process is running ($pid), exiting.\n";
                }
            }

            print STDERR "Ignoring an old lock file, PID $pid is not running.\n";
            last;
        }
        close($fh);
    }

    open(my $fh,'>',$lock) or error("$lock: $!");
    print $fh $$ . "\n";
    close($fh);
}

sub remove_lock
{
    my ($opts) = @_;
    if ( !exists($$opts{lock}) ) { return; }
    my $lock = $$opts{lock};
    if ( -e $lock ) { unlink($lock); }
}

sub read_file_hash
{
    my ($fname) = @_;
    open(my $fh,'<',$fname) or return ();
    my %out = ();
    while (my $line=<$fh>)
    {
        chomp($line);
        if ( $line=~/^\s*(\S+):\s+/ ) { $out{$1} = $'; }
    }
    close($fh);
    return %out;
}
sub elapsed_time
{
    my ($time) = @_;
    my $hours = int($time/3600.); $time -= $hours*3600;
    my $mins  = int($time/60.); $time -= $mins*60;
    return sprintf("%2d:%02d",$hours,$mins);
}

sub update_html_report
{
    my ($opts,$projects) = @_;

    my @finished = list_finished_projects($opts);
    my %finished = ();
    for my $project (@finished) { $finished{$$project{run_id}} = 1; }

    my %chains = ();
    for my $project (@$projects)
    {
        # if the project just finished, it is in both lists: don't show it twice
        if ( $finished{$$project{run_id}} ) { next; }
        push @{$chains{$$project{config}}}, $project;
    }
    for my $project (@finished)
    {
        push @{$chains{$$project{config}}}, $project;
    }

    open(my $fh,'>',$$opts{dropbox_html}) or error("Failed to create html report $$opts{dropbox_html}: $!");
    print $fh qq[<!DOCTYPE html><html>
        <head>
            <title>Runner dropbox $$opts{dropbox}</title>
            <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
            <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/latest/css/bootstrap.min.css">
            <script src="https://code.jquery.com/jquery-latest.min.js" type="text/javascript"></script>
            <style>
                .glyphicon { font-size:1.1em;}
                .material-icons{vertical-align:-14%}
                body { text-align:center;}
                .content { display:inline-block; text-align:left; }
                a { text-decoration: none;}
                a:link { color: #2E6DA4; }
                a:visited { color: #2E6DA4; }
                a:focus { color: #2E6DA4; }
                a:hover { color: green; }
                a:active { color: red; }
                /*
                h1,h2,h3,h4,h5,h6 {
                    margin: 0 0 .5em;
                    font-weight: 500;
                    line-height: 1.1;
                }
                */
                table {
                    background-color: transparent;
                    border-spacing: 0;
                    border-collapse: collapse;
                    /* border-top: 1px solid #ddd; */
                    /* border-bottom: 1px solid #ddd; */
                    margin: 1em;
                }
                th, td {
                    padding: 0.3em 0.7em 0.3em 0.7em;
                }
                th {
                    border-bottom: 1px solid #2E6DA4;
                    text-align: left;
                    vertical-align: bottom;
                }
                .rotate  {
                    display: inline-block;
                    overflow: hidden;
                    width: 1.5em;
                    line-height: 1.5;
                }
                .rotate-inner {
                    display: inline-block;
                    white-space: nowrap;
                    transform-origin: 0 0;
                    transform: translate(0%, 100%) rotate(-90deg);
                }
                .rotate-inner:after {
                    content: "";
                    float: left; 
                    margin-top: 100%;
                }
                .chain {
                    border: black solid 1px;
                    border-radius: .4em;
                    margin-top: 2em;
                }
                .chain-name {
                    background-color: #337ab7;
                    border-color: #2E6DA4;
                    border-radius: .3em;
                    color: white;
                    padding: 0.3em 0.6em 0.3em 0.6em;
                    margin-left: 0.6em;
                }
                .prj-detail {
                    display: none;
                    position: absolute;
                    background-color: #fafafa;
                    border: #ccc solid 1px;
                    border-radius: .4em;
                    padding: 0em;
                    z-index:100;
                }
                .prj-detail table {
                    margin-top:0.5em;
                }
                span.status-btn {
                    width: 1.1em;
                    height: 1.1em;
                    margin-right: 0.3em;
                    margin-left: 0.3em;
                    border-radius: 3px;
                    display: inline-block;
                }
                span.status-done { background-color: #5cb85c; }
                span.status-error { background-color: #d9534f; }
                span.status-running { background-color: #f0ad4e; }
                span.status-todo { background-color: #ccc; }
            </style>
        </head>
        <body>
        <div class="content">

        <h3 style='margin-bottom:0px;'>Runner jobs</h3>
        in <a href="." target="_blank">$$opts{dropbox}</a>
    ];

    my $rel_dbox = $$opts{dropbox};
    $rel_dbox =~ s{^.*/}{};

    my $div_id = 0;
    for my $chain (sort keys %chains)
    {
        my @steps = @{$chains{$chain}[0]{steps}};

        my $name = $chain=~/^chain\.(.+)\.conf$/ ? $1 : $chain;
        print $fh "<div class='chain'><span class='chain-name'>$name</span><table>\n";
        print $fh "<tr>\n";
        print $fh "<th>Project\n";
        print $fh "<th>User\n";
        print $fh "<th><div class='rotate'><div class='rotate-inner'>".join("</div></div><th><div class='rotate'><div class='rotate-inner'>",@steps)."</div></div>";

        for my $project (sort {$$a{run_id} cmp $$b{run_id}} @{$chains{$chain}})
        {
            my $started = '';
            if ( $$project{run_id} =~ /^(\d+)/ ) { $started = strftime("%F %H:%M",gmtime($1)); }

            my $abs_dir = "$$opts{dropbox}.tmp/$$project{run_id}";
            my $rel_dir = "$rel_dbox.tmp/$$project{run_id}";
            my $prj_dir = "$rel_dbox.tmp/$$project{run_id}";
            if ( $$project{finished} )
            {
                $abs_dir = $$project{tmpdir};
                $rel_dir = $abs_dir;
                $rel_dir =~ s{^$$opts{dropbox}}{$rel_dbox};
                $prj_dir = $$project{dir};
                $prj_dir =~ s{^$$opts{dropbox}}{$rel_dbox}; 
            }

            my $is_error = (-e "$abs_dir/$$project{name}.err") ? 1 : 0;
            my @steps_brief  = ();
            my @steps_detail = ();
            my $prev_done = 1;
            my $tot_time;
            for my $step (@{$$project{steps}})
            {
                my $url = '';
                my $url_conf = '';
                my $class = '';
                my $elapsed = '';
                if ( -e "$abs_dir/$$project{name}.$step.done" )
                {
                    my %info = read_file_hash("$abs_dir/$$project{name}.$step.done");
                    if ( $info{started} && $info{finished} ) 
                    { 
                        $elapsed = elapsed_time($info{finished} - $info{started});
                        $tot_time += $info{finished} - $info{started};
                    }
                    $class='status-done'; 
                    if ( -e "$abs_dir/$$project{name}.$step.conf" ) { $url_conf = "$rel_dir/$$project{name}.$step.conf"; }
                }
                elsif ( !-e "$abs_dir/$$project{name}.$step" )  { $class='status-todo'; }
                elsif ( $prev_done )
                {
                    if ( -e "$abs_dir/$$project{name}.$step.conf" ) { $url_conf = "$rel_dir/$$project{name}.$step.conf"; }
                    if ( $is_error )
                    {
                        $class = 'status-error';
                        $url = "$rel_dir/$$project{name}.log";
                    }
                    else
                    {
                        $class = 'status-running'; 
                        if ( -e "$abs_dir/$$project{name}.$step.conf" ) { $url = "$rel_dir/$$project{name}.$step.conf"; }

                        my %info = read_file_hash("$abs_dir/$$project{name}.$step.done.part");
                        if ( $info{started} )
                        {
                            $info{finished} = time();
                            $elapsed = elapsed_time($info{finished} - $info{started}) . '+';
                            $tot_time += $info{finished} - $info{started};
                        }
                    }
                    $prev_done = 0;
                }

                if ( !$url ) { $url = $url_conf; }
                my $url_beg = '';
                my $url_end = '';
                my $url_conf_beg = '';
                my $url_conf_end = '';
                if ( $url ) { $url_beg = "<a href='$url' target='_blank'>"; $url_end = '</a>'; }
                if ( $url_conf ) { $url_conf_beg = "<a href='$url_conf' target='_blank'>"; $url_conf_end = '</a>'; }
                push @steps_brief,"<td style='text-align:center;'>$url_beg<span class='status-btn $class'></span>$url_end\n";
                push @steps_detail,qq[<tr>
                        <td><span class='status-btn $class'></span>
                        <td>$url_conf_beg$step$url_conf_end
                        <td>$elapsed
                    ];
            }

            $tot_time = $tot_time ? elapsed_time($tot_time) : '';
            print $fh "<tr>";
            print $fh qq[
                <td><a style="cursor:pointer;" onclick="\$('#c$div_id').toggle()">$$project{name}</a>
                    <div class='prj-detail' id='c$div_id'>
                    <table>
                        <tr><td style='text-align:center;'>
                                <span class='glyphicon glyphicon-remove' style='cursor:pointer' onclick="\$('#c$div_id').toggle()"></span>
                            <td colspan='2' style='text-align:right;'>
                                <a class='glyphicon glyphicon-info-sign' href='$rel_dir/$$project{name}' target='_blank'></a>
                                <a class='glyphicon glyphicon-home' href='$prj_dir' style='padding-left:1em;' target='_blank'></a>
                        <tr><th><th>Config<th>Time
                    ] .join("\n",@steps_detail). qq[
                        <tr><td><td><td>$tot_time
                        </table>
                    </div>
            ];
            $div_id++;
            print $fh "<td>".(exists($$project{email})?$$project{email}:'');
            for my $step (@steps_brief) { print $fh $step; }

        }
        print $fh "</table>\n";
        print $fh "</div>\n";
    }

    print $fh q[
        </div>
        </body></html>];
    close($fh) or error("Failed to close html report $$opts{dropbox_html}");
}

sub list_finished_projects
{
    my ($opts) = @_;
    my @projects = ();
    opendir(my $dh,$$opts{dropbox_out}) or error("$$opts{dropbox_out}: $!");
    while (my $dir = readdir($dh))
    {
        if ( !-d "$$opts{dropbox_out}/$dir" or !($dir=~/^(\d+)_(.*)$/ ) ) { next; }
        my $run_id = $1;
        my $name   = $2;
        my $tmpdir = "$$opts{dropbox_out}/$dir/tmp-data/$dir";
        my $project = parse_project($opts,$tmpdir,$name,$run_id.'_'.$name);
        if ( !defined $project ) { next; }
        $$project{finished} = 1;
        $$project{tmpdir} = $tmpdir;
        $$project{dir} = "$$opts{dropbox_out}/$dir";
        push @projects, $project;
    }
    close($dh);
    return @projects;
}

sub list_projects
{
    my ($opts) = @_;
    my @projects = ();

    # First check projects in progress. Each project had been assigned a unique
    # name: <numeric timestamp>_<user name>
    #
    my ($dh,$project);
    opendir($dh, $$opts{dropbox_tmp}) or error("$$opts{dropbox_tmp}: $!");
    while (my $dir = readdir($dh))
    {
        if ( !-d "$$opts{dropbox_tmp}/$dir" or !($dir=~/^\d+_(.*)$/ ) ) { next; }
        my $name   = $1;
        my $run_id = $dir;
        $project   = parse_project($opts,"$$opts{dropbox_tmp}/$dir",$name,$run_id);
        if ( !defined $project ) { next; }
        push @projects, $project;
        if ( exists($$opts{nmax_projects}) && scalar @projects >= $$opts{nmax_projects} ) { last; }
    }
    closedir($dh);
    if ( exists($$opts{nmax_projects}) && scalar @projects >= $$opts{nmax_projects} ) { return \@projects; }

    # No unfinished projects, check for new projects. File names starting
    # with a dot, ending with ~, or .err are ignored. Everything else is
    # parsed as an input.
    #
    opendir($dh, $$opts{dropbox_in}) or error("$$opts{dropbox_in}: $!");
    while (my $file = readdir($dh))
    {
        if ( $file =~/^\./ ) { next; }
        if ( $file =~/~$/ ) { next; }
        if ( $file =~/\.err$/ ) { next; }

        my $name   = $file;
        my $run_id = time() .'_'. $name;
        $project   = parse_project($opts,$$opts{dropbox_in},$name,$run_id);
        if ( !defined $project ) { next; }

        system("mkdir -p $$opts{dropbox_tmp}/$$project{run_id}");
        system("mv $$opts{dropbox_in}/$name $$opts{dropbox_tmp}/$$project{run_id}/$name");
        if ( $? ) 
        { 
            # cannot move because of permissions, skip
            print STDERR "mv $$opts{dropbox_in}/$name $$opts{dropbox_tmp}/$$project{run_id}/$name"; 
            ulink("$$opts{dropbox_tmp}/$$project{run_id}/$name");
            next;
        }
        if ( exists($$project{chgrp}) )
        {
            # set group permissions
            system("cp $$opts{dropbox_tmp}/$$project{run_id}/$name $$opts{dropbox_tmp}/$$project{run_id}/$name.part");
            system("chmod g+w $$opts{dropbox_tmp}/$$project{run_id}/$name.part");
            system("mv -f $$opts{dropbox_tmp}/$$project{run_id}/$name.part $$opts{dropbox_tmp}/$$project{run_id}/$name");
            system("chgrp -R $$project{chgrp} $$opts{dropbox_tmp}/$$project{run_id}"); 
        }

        push @projects, $project;
        if ( exists($$opts{nmax_projects}) && scalar @projects >= $$opts{nmax_projects} ) { last; }
    }
    closedir($dh);
    return \@projects;
}

sub clean_project
{
    my ($opts,$project) = @_;

    my $name = $$project{name};
    debug_msg($opts,"Cleaning project: $name\n");
    $$project{prefix} = "$$opts{dropbox_tmp}/$$project{run_id}/$name";

    for my $dst (sort keys %{$$project{outputs}})
    {
        # Create a subdirectory '$dst' and move all listed files in there:
        #   dst => [ 'src1','src2' ]
        #
        # Move src file in dst
        #   dst => 'src',
        #
        if ( ref($$project{outputs}{$dst}) eq 'ARRAY' )
        {
            cmd($opts,"mkdir -p $$opts{dropbox_out}/$$project{run_id}/$dst");
            if ( exists($$project{chgrp}) ) { system("chgrp -R $$project{chgrp} $$opts{dropbox_out}/$$project{run_id}"); }
            for my $file (@{$$project{outputs}{$dst}})
            {
                my $src = expand_vars({%$opts,%$project},$file);
                cmd($opts,"mv $src $$opts{dropbox_out}/$$project{run_id}/$dst/");
            }
        }
        else
        {
            my $dir = "$$opts{dropbox_out}/$$project{run_id}";
            my $src = $$project{outputs}{$dst};
            if ( $dst =~ m{([^/]+)$} ) { $dir = "$dir/$`"; $dst = "$dir/$1"; }
            cmd($opts,"mkdir -p $dir");
            if ( exists($$project{chgrp}) ) { system("chgrp $$project{chgrp} $dir"); }
            $src = expand_vars({%$opts,%$project},$src);
            cmd($opts,"mv $src $dst");
        }
    }
    cmd($opts,"mkdir -p $$opts{dropbox_out}/$$project{run_id}/tmp-data");
    cmd($opts,"mv $$opts{dropbox_tmp}/$$project{run_id} $$opts{dropbox_out}/$$project{run_id}/tmp-data");
}

# Parse the project definition. There are three levels: setup, chain and steps. Setup can
# override defaults in chain and steps, chain can override steps.
sub parse_project
{
    my ($opts,$dir,$name,$run_id) = @_;
    my %project = ();
    my %setup   = ();

    # the error period can be overriden by projects, set the default here
    $project{err_period} = $$opts{err_period};

    # parse the setup file
    my $file = "$dir/$name";
    open(my $fh,'<',$file) or error("$file: $!");
    while (my $line=<$fh>)
    {
        if ( $line=~/^\s*#/ ) { next; }
        if ( $line=~/^\s*$/ ) { next; }
        $line =~ s/^\s*//;
        $line =~ s/\s*$//;
        if ( !($line=~/^\s*([^:]+)\s*:/) ) 
        { 
            print STDERR "Could not parse $file: $line\n";
            if ( $$opts{ignore_failures} ) { return undef; }
            error("Failed: $file\n");
        }
        my $key = $1;
        my $value = $';
        $value =~ s/^\s*//;
        $value =~ s/\s*$//;
        $value = parse_config_value($value);    # expand deep variables (arrays or hashes)
        $key   =~ s/\s*$//;

        if ( $key =~ /^\./ )    # "global" variables start with a dot
        {
            $key = $';
            $project{$key} = $value;
            next;
        }

        # User variable can override a default chain or step config key.
        # Determine the step which this config key belongs to.
        if ( $key =~ m{/} )
        {
            my $step  = $`;
            my $key   = $';
            my @steps = ($step=~/,/) ? split(/\s*,\s*/,$step) : ($step);
            for my $step (@steps) { $setup{"$step/$key"} = $value; }
            next;
        }

        # The key is meant to override all steps
        $setup{"*/$key"} = $value;
    }
    close($fh) or error("close failed: $file");
    $project{setup_file} = $file;
    $project{name}   = $name;
    $project{run_id} = $run_id;
    $project{prefix} = $project{chdir_into_project} ? $name : "$$opts{dropbox_tmp}/$run_id/$name";

    my %email = ();
    if ( exists($project{email}) ) { %email = map { $_=>1 } split(/\s+/,$project{email}); }
    if ( exists($$opts{admin_email}) ) { $email{$$opts{admin_email}} = 1; }
    if ( scalar keys %email ) { $project{email} = join(' ',keys %email); }

    my $chain = parse_chain($opts,\%project);
    if ( !defined $chain )
    {
        if ( $$opts{ignore_failures} ) { return undef; }
        error("Failed: $file\n");
    }

    # Parse all steps and expand variables
    for my $step_name (@{$$chain{steps}})
    {
        my $step = parse_step($opts,\%project,\%setup,$chain,$step_name);
        if ( !defined $step )
        {
            if ( $$opts{ignore_failures} ) { return undef; }
            error("Failed: $file\n");
        }
        $project{$step_name} = $step;
    }
    %project = ( %$chain, %project );
    return \%project;
}

sub parse_chain
{
    my ($opts,$project) = @_;

    # Read the chain file
    if ( !exists($$project{config}) )
    {
        print STDERR "Config not present in $$project{setup_file}\n";
        return undef;
    }
    if ( $$project{config} =~ m{/} )
    {
        print STDERR "The config must be a plain file in $$opts{dropbox_conf},\n";
        print STDERR "please remove the directory part from $$project{config}\n";
        print STDERR "in $$project{setup_file}.\n";
        return undef;
    }
    my $chain_file = "$$opts{dropbox_conf}/$$project{config}";
    my $ret = open(my $fh,'<',$chain_file);
    if ( !$ret ) 
    {
        print STDERR "No such config in $$opts{dropbox_conf}:\n\t$chain_file\n";
        return undef;
    }
    my @config_lines = <$fh>;
    close($fh) or error("close failed: $chain_file");
    my $config_str = join('',@config_lines);
    my $x = eval "{ $config_str }";
    if ( $@ ) { error("eval $chain_file: $@\n"); }

    if ( !exists($$x{steps}) )
    {
        print STDERR "The chain has no steps: $chain_file\n";
        return undef;
    }
    $$project{chain_file} = $chain_file;

    return $x;
}

sub parse_config_value
{
    my ($value) = @_;
    if ( $value=~/^\[/ && $value=~/\]$/ or $value=~/^\{/ && $value=~/\}$/ )
    {
        my $val = eval "$value";
        if ( !$@ ) { $value = $val; }
    }
    elsif ( $value eq 'undef' ) { $value = undef; }
    elsif ( $value eq "'undef'" or $value eq '"undef"' ) { $value = 'undef'; }
    return $value;
}

sub parse_step
{
    my ($opts,$project,$setup,$chain,$step_name) =  @_;

    if ( !exists($$chain{$step_name}) )
    {
        print STDERR "Undefined step in $$project{chain_file}\n";
        return undef;
    }

    my $step = {};
    if ( exists($$chain{$step_name}{include}) )
    {
        my $step_file = "$$opts{dropbox_conf}/$$chain{$step_name}{include}";
        open(my $fh,'<',$step_file) or error("$step_file: $!");
        my @step_lines = <$fh>;
        close($fh) or error("close failed: $step_file");

        my $tmp = join('',@step_lines);
        $step = eval "{ $tmp }";
        if ( $@ ) 
        { 
            print STDERR "eval $step_file: $@\n"; 
            return undef;
        }
    } 

    # the step's keys "run" and "config" can be overriden by chain
    %$step = ( %$step, %{$$chain{$step_name}} );

    # set step-specific keys ("pbwt/key: value") and keys shared by all steps ("*/key: value")
    my %reserved = map { $_ => 1 } (qw(include run));
    my %predef = ( prefix=>$$project{prefix} );
    for my $var (sort keys %$setup)
    {
        my ($name,$key) = split(m{/},$var);
        if ( $name eq '*' or $name eq $step_name )
        {
            $$step{$key} = $$setup{$var};
            if ( !exists($predef{$key}) && defined $$setup{$var} ) { $predef{$key} = $$setup{$var}; }
        }
    }
    for my $var (sort keys %{$$chain{$step_name}})
    {
        if ( $reserved{$var} or exists($predef{$var}) or !defined $$chain{$step_name}{$var} ) { next; }
        $predef{$var} = expand_vars(\%predef,$$chain{$step_name}{$var});
    }

    # expand 
    for my $key (sort keys %$step)
    {
        my $value = $$step{$key};
        if ( !defined $value ) { next; }    # allow undef as override
        $value = expand_vars(\%predef,$value);
        $value = parse_config_value($value);    # eval array/hash chain variables
        $$step{$key} = $value;
    }

    if ( exists($$step{config}) )
    {
        # override defaults in step's runner config. Originally, only keys
        # from the step.config would be written, but that was inconvenient.
        # Now we include all predefeined keys in the config.
        for my $key (sort keys %predef)
        {
            if ( $reserved{$key} ) { next; } # reserved keys: include,run
            $$step{config}{$key} = parse_config_value($predef{$key});
        }

        use Data::Dumper;
        my @config_lines = split(/\n/,Dumper($$step{config}));
        shift(@config_lines);       # get rid of $VAR1 = { .. } lines
        pop(@config_lines);
        $$step{config} = join("\n",@config_lines)."\n";
    }

    return $step;
}

# Replace variables $(var_name)
sub expand_vars
{
    my ($vars,$str) = @_;
    pos($str) = 0;
    while ( ($str =~ /\G(.*?)\$\(([^:\)]+):([^\)]*)\)/s) )
    {
        if ( !defined pos($str) ) { pos($str) = 0; }
        pos($str) += length($&);
        if ( exists($$vars{$2}) ) 
        { 
            $str = $` . $1 . $$vars{$2} . $'; 
            next; 
        }
        else
        {
            $str = $` . $1 . $3 . $';       # replace "$(string:200)" with "200" if key "string" is not present
        }
    }
    pos($str) = 0;
    while ( ($str =~ /\G(.*?)\$\(([^\)]+)\)/s) )
    {
        if ( !defined pos($str) ) { pos($str) = 0; }
        pos($str) += length($&);
        if ( exists($$vars{$2}) ) 
        { 
            $str = $` . $1 . $$vars{$2} . $'; 
            next; 
        }
    }
    return $str;
}

sub first_file_newer
{
    my ($a,$b) = @_;
    my $atime = (stat($a))[9];
    my $btime = (stat($b))[9];
    return $atime > $btime ? 1 : 0;
}

sub debug_msg
{
    my ($opts,@msg) = @_;
    if ( !$$opts{verbose} ) { return; }
    print STDERR join('',@msg);
}

# Create a config file for each step in project (if the key "config" exists for
# the step) and run all runners until finished.
sub run_project
{
    my ($opts,$project) = @_;
    my $name = $$project{name};
    debug_msg($opts,"Checking status: $name\n");
    for my $step (@{$$project{steps}})
    {
        my $prefix = "$$opts{dropbox_tmp}/$$project{run_id}/$name";
        debug_msg($opts, "Checking step: $prefix.$step.done\n");
        if ( -e "$prefix.$step.done" ) 
        { 
            debug_msg($opts, "step done: $prefix.$step\n");
            next; 
        }
        if ( ! -e "$prefix.$step" ) 
        { 
            open(my $fh,'>',"$prefix.$step.done.part") or error("$prefix.$step.done.part: $!");
            print $fh "started:\t".time()."\n";
            close($fh) or error("close failed: $prefix.$step.done.part");
            system("mkdir -p $prefix.$step"); 
        }
        $$project{step} = $step;

        if ( exists($$project{$step}{config}) && !-e "$prefix.$step.conf" )
        {
            my $config = expand_vars({%$opts,%{$$project{$step}}},$$project{$step}{config});
            open(my $fh,'>',"$prefix.$step.conf.part") or error("$prefix.$step.conf.part: $!");
            print $fh $config;
            close($fh) or error("close failed: $prefix.$step.conf.part");
            rename("$prefix.$step.conf.part","$prefix.$step.conf") or error("rename $prefix.$step.conf.part $prefix.$step.conf: $!");
        }

        my $cwd;
        if ( $$project{chdir_into_project} )
        {
            debug_msg($opts,"chdir $$opts{dropbox_tmp}/$$project{run_id}\n");
            $cwd = getcwd;
            chdir("$$opts{dropbox_tmp}/$$project{run_id}");
        }
        my $ret = run_step($opts,$project,$step);
        if ( defined $cwd ) { chdir($cwd); }
        if ( !$ret ) { return; }

        open(my $fh,'>>',"$prefix.$step.done.part") or error("$prefix.$step.done.part: $!");
        print $fh "finished:\t".time()."\n";
        close($fh) or error("close failed: $prefix.$step.done.part");
        rename("$prefix.$step.done.part","$prefix.$step.done") or error("rename $prefix.$step.done.part $prefix.$step.done: $!");
    }
    clean_project($opts,$project);
    send_email($project,"The project \"$name\" finished","The project \"$name\" finished:\n\t$$opts{dropbox_out}/$$project{run_id}");
}

sub cmd
{
    my ($opts,$cmd) = @_;

    if ( $$opts{verbose} ) { print STDERR "$cmd\n"; }

    my $tmp = $$opts{lock} ? $$opts{lock} : "/tmp/runners.$$";
    open(my $stderr,'>',"$tmp.e") or confess("$tmp.e: $!");
    open(my $stdout,'>',"$tmp.o") or confess("$tmp.o: $!");

    my @cmd = ('/bin/bash', '-o','pipefail','-c', $cmd);
    run3 \@cmd,undef,$stdout,$stderr;

    close($stderr);
    close($stdout);

    my $signal  = $? & 127;
    my $status  = $? >> 8;

    my (@out,@err);
    if ( open(my $fh,'<',"$tmp.o") )
    {
        @out = <$fh>;
        close($fh);
    }
    if ( open(my $fh,'<',"$tmp.e") )
    {
        @err = <$fh>;
        close($fh);
    }
    unlink("$tmp.o");
    unlink("$tmp.e");

    return ($signal,$status,\@out,\@err);
}

# Run a single runner. There can be multiple steps per pipeline (project).
sub run_step
{
    my ($opts,$project,$step_name) = @_;
    my $step = { %{$$project{$step_name}} };
    $$step{prefix} = $$project{prefix};
    $$step{step}   = $step_name;
    for (my $icmd=0; $icmd<@{$$step{run}}; $icmd++)
    {
        my $job = $$step{run}[$icmd];

        my $done_file = "$$project{prefix}.$step_name.$icmd.done";
        if ( -e $done_file ) { next; }
        cmd($opts,"touch $done_file.part");

        my $cmd = expand_vars({%$project,%$step},$$job{cmd});

        if ( !exists($$job{status}) or !exists($$job{status}{done}) ) { $$job{status}{done} = [0]; }
        my %done = map { $_=>1 } @{$$job{status}{done}};
        my %loop = exists($$job{status}{loop}) ? map { $_=>1 } @{$$job{status}{loop}} : ();

        while ( 1 )
        {
            debug_msg($opts, "Running step $step_name: $cmd\n");
            my ($signal,$status,$out,$err) = cmd($opts,$cmd);
            if ( $$opts{verbose} )
            {
                print @$out;
                print STDERR @$err;
            }
            if ( !$signal && $done{$status} )
            {
                rename("$done_file.part",$done_file) or error("rename $done_file.part $done_file: $!");
                last; 
            }
            if ( !$signal && $loop{$status} )
            {
                if ( !$$opts{loop} ) { return 0; }
                print STDERR "sleeping $$opts{loop} seconds..\n" unless !$$opts{verbose};
                sleep($$opts{loop}); 
            }
            else 
            { 
                my $out = @$out ? join('',@$out) : '<none>';
                my $err = @$err ? join('',@$err) : '<none>';
                my $msg = 
                        "\n---\nError: unexpected signal/status ($signal/$status) from the command:\n" .
                        "\t$cmd\n\n".
                        "Working directory:\n\t$$opts{dropbox_tmp}/$$project{run_id}/\n\n".
                        "Standard output:\n$out\n\n".
                        "Error output:\n$err\n---\n\n";

                send_err_email($project,"$step_name error",$msg);

                if ( $$opts{ignore_failures} )
                {
                    print STDERR "Failed: $cmd\n\n";
                    return 0;   # Act as if the step has not finished
                }
                error($msg); 
            }
        }
    }
    return 1;
}

sub send_email
{
    my ($opts, $status, @msg) = @_;
    if ( !exists($$opts{email}) ) { return; }
    open(my $mh,"| mail -s 'Runner report: $status' $$opts{email}");
    print $mh join('',@msg) . "\n";
    close($mh);
}
sub send_err_email
{
    my ($opts, $status, @msg) = @_;
    if ( !exists($$opts{email}) ) { return; }
    if ( exists($$opts{err_period}) )
    {
        my $err_file = "$$opts{prefix}.err";
        if ( -e $err_file ) 
        {
            if ( !update_after_delta($err_file,$$opts{err_period}*60) ) { return; }
        }
        open(my $fh,'>',$err_file) or error("$err_file: $!");
        my $now = time();
        print $fh $now;
        close($fh) or error("$err_file: close failed");

        my $log_file = "$$opts{prefix}.log";
        open($fh,'>',$log_file) or error("$log_file: $!");
        print $fh @msg;
        close($fh) or error("$log_file: close failed");
    }
    send_email($opts, $status, @msg);
}

sub update_after_delta
{
    my ($err_file,$period) = @_;
    my $now = time();
    my $ret = open(my $fh,'<',$err_file);
    if ( $ret )
    {
        my $then = <$fh>;
        close($fh);
        if ( $then )
        {
            chomp($then);
            if ( $then + $period > $now ) { return 0; }
        }
    }
    open($fh,'>',$err_file) or return 1;
    print $fh $now;
    close($fh);
    return 1;
}


